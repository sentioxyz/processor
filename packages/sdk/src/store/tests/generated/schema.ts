/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { String, Int, BigInt, Float, ID, Bytes, Timestamp, Boolean } from '@sentio/sdk/store'
import { Entity, Required, One, Many, Column, ListColumn, AbstractEntity } from '@sentio/sdk/store'
import { BigDecimal } from '@sentio/bigdecimal'
import { DatabaseSchema } from '@sentio/sdk'

export enum TransactionStatus {
  SUCCESS = 'SUCCESS',
  FAILURE = 'FAILURE'
}

export interface Owner {
  id: ID
  name: String
}

@Entity('Transaction')
export class Transaction extends AbstractEntity {
  @Required
  @Column('ID')
  id: ID

  @Required
  @One('Owner')
  sender: Promise<Owner>

  senderID: ID

  @Required
  @Column('BigInt')
  gas: BigInt

  @Required
  @Column('BigDecimal')
  gasPrice: BigDecimal

  @Column('Boolean')
  isSuccess?: Boolean

  @Column('Bytes')
  raw?: Bytes

  @Column('Int')
  count?: Int

  @Column('Float')
  value?: Float

  @Required
  @ListColumn('String')
  arrayValue: Array<String>

  @ListColumn('String!')
  arrayValue2?: Array<String>

  @Required
  @ListColumn()
  @ListColumn('String')
  arrayOfArrayValue: Array<Array<String>>

  @Column('Timestamp')
  dateValue?: Timestamp

  @Required
  @Many('TransactionReceipt!')
  receipts: Promise<Array<TransactionReceipt>>

  receiptsIDs: Array<ID | undefined>
  constructor(data: Partial<Transaction>) {
    super()
  }
}

@Entity('TransactionReceipt')
export class TransactionReceipt extends AbstractEntity {
  @Required
  @Column('ID')
  id: ID

  @Column('String')
  status?: TransactionStatus

  @One('Transaction')
  transaction: Promise<Transaction | undefined>

  transactionID: ID
  constructor(data: Partial<TransactionReceipt>) {
    super()
  }
}

@Entity('User')
export class User extends AbstractEntity implements Owner {
  @Required
  @Column('ID')
  id: ID

  @Required
  @Column('String')
  name: String

  @Required
  @Many('Transaction!')
  transactions: Promise<Array<Transaction>>

  transactionsIDs: Array<ID | undefined>

  @Required
  @Many('Organization!')
  organizations: Promise<Array<Organization>>

  organizationsIDs: Array<ID | undefined>
  constructor(data: Partial<User>) {
    super()
  }
}

@Entity('Organization')
export class Organization extends AbstractEntity implements Owner {
  @Required
  @Column('ID')
  id: ID

  @Required
  @Column('String')
  name: String

  @Required
  @Many('User!')
  members: Promise<Array<User>>

  membersIDs: Array<ID | undefined>
  constructor(data: Partial<Organization>) {
    super()
  }
}

export class NonEntity {
  id?: ID
}

const source = `type Transaction @entity {
  id: ID!
  sender: Owner!
  gas: BigInt!
  gasPrice: BigDecimal!
  isSuccess: Boolean
  raw: Bytes
  count: Int
  value: Float
  arrayValue: [String]!
  arrayValue2: [String!]
  arrayOfArrayValue: [[String]]!
  dateValue: Timestamp
  receipts: [TransactionReceipt!]! @derivedFrom(field: "transaction")
}

type TransactionReceipt @entity {
  id: ID!
  status: TransactionStatus
  transaction: Transaction
}

interface Owner  {
  id: ID!
  name: String!
}

type User implements Owner @entity {
  id: ID!
  name: String!
  transactions: [Transaction!]! @derivedFrom(field: "sender")
  organizations: [Organization!]! @derivedFrom(field: "members")
}

type Organization implements Owner @entity(sparse: true) {
  id: ID!
  name: String!
  members: [User!]!
}

type NonEntity {
  id: ID
}

enum TransactionStatus {
  SUCCESS
  FAILURE
}`
DatabaseSchema.register({
  source,
  entities: {
    Transaction: Transaction,
    TransactionReceipt: TransactionReceipt,
    User: User,
    Organization: Organization,
    NonEntity: NonEntity
  }
})
